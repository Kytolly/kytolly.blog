<!DOCTYPE html>
<html>
<meta charset="utf-8" />
  <!-- 标签页 -->
  <!-- 标签页 -->
<title>
    面向对象的系统设计
</title>


<link rel="shortcut icon" href="/icon.svg">


  <body>  
    <!-- 配置引用 -->
    <script>
  window.THEME_CONFIG = {
    image: {
      enable: 'true',
      center: 'true',
      caption: 'false'
    },
    code_block: {
      copy_button: "icon/copy.svg",
      theme_toggle: {
        enable: 'true',
        to_light_button: "icon/light.svg",
        to_dark_button: "icon/dark.svg",
        light_theme: "/css/vscode-modern-light.css",
        dark_theme: "/css/vscode-modern-dark.css"
      },
      mac_enhancer: {
        enable: 'true',
        init_folded_status: 'true'
      }
    },
    giscus: {
      repo: "Kytolly/MyGiscus",
      repo_id: "R_kgDOK_0_0A",
      category: "Announcements",
      category_id: "DIC_kwDOK_0_0A",
      mapping: "pathname",
      strict: "0",
      reactions_enabled: "1",
      emit_metadata: "0",
      input_position: "top",
      lang: "zh-CN",
      loading: "lazy"
    },
    heading_numbering: 'true',
    three_line_table: 'true',
    background: {
      enable: 'true',
      folder: 'img/',
      opacity: '0.1',
      position: 'center',
      size: 'cover',
      repeat: 'no-repeat',
      image: {
        mode: 'random',
        name: 'background.jpg',
        count: '113'
      }
    },
  };
</script>
<script>
  console.log(window.THEME_CONFIG);
</script>

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    
    <!-- 字体 -->
    <!-- 字体 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

    <!-- 代码块 -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    
      
        <link rel="stylesheet" href="/css/vscode-modern-light.css">
        <link rel="stylesheet" href="/css/vscode-modern-dark.css">
        <!-- DEBUG: url_for light path: /css/vscode-modern-light.css -->
        <!-- DEBUG: url_for dark path: /css/vscode-modern-dark.css -->
      
    
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>

    <!-- 数学公式 -->
    
<link rel="stylesheet" href="/css/mathjax.css">

    
<script src="/js/mathjax.js"></script>

    
    <!-- 标题编号 -->
    
      
<link rel="stylesheet" href="/css/heading-numbering.css">

      
<script src="/js/heading-numbering.js"></script>

    
    
    <!-- 三线表样式 -->
    
      
<link rel="stylesheet" href="/css/three-line-table.css">

    
  
    <!-- 图片样式 -->
    
      
<link rel="stylesheet" href="/css/image-handler.css">

      
<script src="/js/image-handler.js"></script>

    
    
  
    
<link rel="stylesheet" href="/css/root.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/post.css">


    <!-- 代码块基础样式 -->
    
<link rel="stylesheet" href="/css/code-block-base.css">

  
    <!-- Codeblock Theme Toggler CSS -->
    
    
<link rel="stylesheet" href="/css/codeblock-theme-toggle.css">

    
  
    <!-- Codeblock Mac Enhancer CSS -->
    
    
<link rel="stylesheet" href="/css/code-block-mac-enhancer.css">

    
  
    <!-- TOC 样式 -->
    <link rel="stylesheet" href="/css/toc.css">
    
  <!-- hexo injector head_end start -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
</head>


    <div class="site-container">
      <!-- 导航栏 -->
      <!--(头部 top bar) Header 样式 -->

<link rel="stylesheet" href="/css/header.css">


<header class="header">
  <section class="header-container">
    <a class="header-logo" href="/">Kytolly&#39;s Blog</a>
    <div class="header-right-section">
      <ul class="header-nav">
        
        <li>
          <a href="/">
            <img src="/icon/index.svg" alt="index icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
            index
          </a>
        </li>
        
        <li>
          <a href="/archive">
            <img src="/icon/archive.svg" alt="archive icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
            archive
          </a>
        </li>
        
        <li>
          <a href="/tag">
            <img src="/icon/tag.svg" alt="tag icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
            tag
          </a>
        </li>
        
        <li>
          <a href="/about">
            <img src="/icon/about.svg" alt="about icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
            about
          </a>
        </li>
        
      </ul>
      
      
      <div class="header-search-container search-trigger">
        <img src="/icon/search.svg" alt="Search Icon" class="search-icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
        <input type="text" id="header-search-input" placeholder="searching..." readonly>
      </div>
      
    </div>
  </section>
</header>


<script src="/js/search.js"></script>


      <!-- 路由 根据页面类型决定渲染内容 -->
      <main class="main">
  
    <article class="post-container">
  <!-- 可选：左侧跟随目录 -->
  
  <aside id="toc-container" class="toc-container toc-left toc-expanded">
    <div id="toc-title" class="toc-title">面向对象的系统设计</div>
    <div id="toc-content" class="toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%B4%BB%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">面向对象设计活动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">用例设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">类设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">UML顺序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">面向对象的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象设计的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">2.2.</span> <span class="toc-text">面向对象设计的四个层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">设计高质量的软件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%86%85%E8%81%9A"><span class="toc-number">2.3.1.</span> <span class="toc-text">强内聚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E8%80%A6%E5%90%88"><span class="toc-number">2.3.2.</span> <span class="toc-text">弱耦合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">可重用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">2.5.</span> <span class="toc-text">框架</span></a></li></ol></li></ol>
    </div>
  </aside>
 


<script src="/js/toc.js"></script>


  <!-- 可选：右侧 AI 摘要 -->
  

  <div class="post-main-wrapper">
    <!-- 文章 -->
    <div class="post-title">面向对象的系统设计</div>
  <div class="post-meta">
    <div class="date">2025 七月 5日</div>
    <div class="tags">
      
        
        <div class="tag-item">Coursework</div>
        
        <div class="tag-item">Software-Engineering</div>
        
      
    </div>
  </div>

<main class="post-content"><h2 id="面向对象设计活动"><a href="#面向对象设计活动" class="headerlink" title="面向对象设计活动"></a>面向对象设计活动</h2>
<p>包括系统架构设计，用例设计，类设计，数据库设计，用户界面设计；</p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3>
<p>架构设计的目的是要勾画出系统的总体结构，这项工作由经验丰富的架构设计师主 持完成。</p>
<ul>
<li>输入：用例模型、分析模型</li>
<li>输出：物理结构、子系统及其接口、概要的设计类</li>
</ul>
<p><img src="/assets/Software-Engineering/image-20241027204108264.png" alt="image-20241027204108264"></p>
<p>步骤</p>
<ol>
<li>
<p>构造系统的物理模型</p>
<ul>
<li>首先用UML的配置图（部署图）描述系统的物理架构</li>
<li>将需求分析阶段捕获的系统功能分配到这些物理节点上</li>
<li>配置图上可以显示计算节点的拓扑结构、硬件设备配置、通信路径、各个节点上运 行的系统软件配置、应用软件配置</li>
</ul>
</li>
<li>
<p>设计子系统</p>
<ul>
<li>
<p>对于一个复杂的软件系统来说，将其分解成若干个子系统，子系统内还可以继续划 分子系统或包，这种自顶向下、逐步细化的组织结构非常符合人类分析问题的思路； 每个子系统与其它子系统之间应该定义接口，在接口上说明交互信息，注意这时还不要描述子系统的内部实现，可用UML组件图表示；</p>
</li>
<li>
<p>划分各个子系统</p>
<ul>
<li>按照功能划分，将相似的功能组织在一个子系统中；</li>
<li>按照系统的物理布局划分，将在同一个物理区域内的软件组织为一个子系统；</li>
<li>按照软件层次划分子系统，软件层次通常可划分为用户界面层、专用软件层、通用软件层、 中间层和数据层</li>
</ul>
</li>
<li>
<p>定义子系统之间的关系</p>
</li>
<li>
<p>定义子系统的接口</p>
<ul>
<li>
<p>每个子系统的接口上定义了若干操作，体现了子系统的功能，而功能的具体实现方 法应该是隐藏的，其他子系统只能通过接口间接地享受这个子系统提供的服务，不 能直接操作它。</p>
</li>
<li>
<p>如果两个子系统之间的关系过于密切，则说明一个子系统的变化会导致另一个子系 统变化，这种子系统理解和维护都会比较困难。</p>
</li>
<li>
<p>解决子系统之间关系过于密切的办法基本上有两个：</p>
<p>重新划分子系统，这种方法比较简单，将子系统的粒度减少，或者重新规划子系统的内容， 将相互依赖的元素划归到同一个子系统之中；</p>
<p>定义子系统的接口，将依赖关系定义到接口上</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非功能需求设计</p>
<ul>
<li>分析阶段定义了整个系统的非功能需求，在设计阶段要研究这些需求，设计出可行 的方案</li>
<li>非功能需求包括系统的安全性、错误监测和故障恢复、可移植性和通用性</li>
<li>具有共性的非功能需求一般设计在中间层和通用应用层，目的是充分利用已有构件， 减少重新开发的工作量。</li>
</ul>
</li>
</ol>
<h3 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h3>
<p>进一步细化用例：</p>
<ul>
<li>根据分析阶段产生的<strong>高层类图和交互图</strong>，由用例设计师研究已有的类，将它们分配 到相应的用例中</li>
<li>检查每个用例功能，依靠当前的类能否实现，同时检查每个用例的特殊需求是否有 合适的类来实现</li>
<li>细化每个用例的类图，描述<strong>实现用例的类及其类之间的相互关系</strong>，其中的通用类和 关键类可用粗线框区分，这些类将作为项目经理检查项目时的重点。</li>
</ul>
<p>步骤：</p>
<ol>
<li>通过扫描用例中所有的交互图识别参与用例解决方案的类。在设计阶段完 善类、属性和方法。例如，每个用例至少应该有一个控制类，它<strong>通常没有属性而只有方法</strong>，它本身不完成什么具体的功能，只是起协调和控制作用；</li>
<li>每个类的方法都可以通过分析交互图得到，一般地检查所有的交互图发送给某个类的所有 消息，这表明了该类必须定义的方法</li>
<li>添加属性的类型、方法的参数类型和方法的返回类型</li>
<li>添加类之间的关系，包括关联、依赖、泛化等。</li>
</ol>
<h3 id="类设计"><a href="#类设计" class="headerlink" title="类设计"></a>类设计</h3>
<p>类是包含信息和影响信息行为的逻辑元素。</p>
<p>类的符号是由三个格子的长方形组成， 有时下面两个格子可以省略。 ▪</p>
<ul>
<li>最顶部的格子包含类的名字，类的命名应尽量用应用领域中的术语，有明确的含义， 以利于开发人员与用户的理解和交流。</li>
<li>中间的格子说明类的属性。</li>
<li>最下面的格子是 类的操作行为。</li>
</ul>
<p><img src="/assets/Software-Engineering/image-20241027215440730.png" alt="image-20241027215440730"></p>
<p>类图中的基本关系</p>
<ul>
<li>关联关系</li>
<li>聚合关系</li>
<li>组合关系</li>
<li>依赖关系</li>
<li>泛化关系</li>
</ul>
<p>分析类图示例：</p>
<p><img src="/assets/Software-Engineering/image-20241027215641471.png" alt="image-20241027215641471"></p>
<p>设计类图</p>
<p><img src="/assets/Software-Engineering/image-20241027215658896.png" alt="image-20241027215658896"></p>
<p>如何寻找实体类</p>
<ul>
<li>实体类用于对必须存储的信息和相关行为进行建模</li>
<li>实体类源于业务模型中的业务实体，但是对于系统结构的优化，可以在后续的过程中被分拆和合并</li>
</ul>
<p>如何寻找边界类</p>
<ul>
<li>参与者与用例之间应当建立边界类</li>
<li>用例与用例之间如果有交互，应当为其建立边界类</li>
<li>如果用例与系统边界之外的非人对象有交互，应当为其建立边界类</li>
<li>在相关联的业务对象有明显的独立性要求，即它们可能在各自的领域内发展和变化， 但又希望互不影响时，也应当为它们建立边界类</li>
</ul>
<p>如何寻找控制类</p>
<ul>
<li>控制类来源于对用例场景中动词的分析和定义</li>
<li>控制类主要起到协调对象的作用，例如从边界类通过控制类访问实体类，或者实体类通过控制类访问另一个实体类</li>
<li>如果用例场景中的行为在执行步骤、执行要求或者执行结果上具有类似的特征，应当合并或抽取超类</li>
</ul>
<p>详细设计一个类的步骤</p>
<ol>
<li>定义类的属性
<ul>
<li>用所选择的编程语言定义每个类的属性。类的属性反映类的特性，通常属性是被封装在 类的内部，不允许外部对象访问</li>
<li>分析阶段和概要设计阶段定义的一个类属性在详细设计时可能要被分解为多个，减小属性的表示粒度有利于实现和重用。</li>
<li>但是一个类的属性如果太多，则应该检查一下，看能否分离出一个 新的类。</li>
<li>如果一个类因为其属性的原因变得复杂而难于理解，那么就将一些属性分离出来形成一个新的类。</li>
<li>通常不同的编程语言提供的数据类型有很大差别，确定类的属性时要用编程语言来约束可用的 属性类型。</li>
<li>定义属性类型时尽可能使用已有的类型，太多的自定义类型会降低系统的可维护性 和可理解性等性能指标。</li>
<li>类的属性结构要坚持简单的原则，尽可能不使用复杂的数据结构</li>
</ul>
</li>
<li>定义类的操作
<ul>
<li>由构件工程师为每个类的方法设计必须实现的操作，并用自然语言或伪代码描述操 作的实现算法。一个类可能被应用在多个用例中，由于它在不同用例中担当的角色 不同，所以设计时要求详细周到。</li>
<li>分析类的每个职责的具体含义，从中找出类应该具备的操作。</li>
<li>阅读类的非功能需求说明，添加一些必须的操作。</li>
<li>确定类的接口应该提供的操作。这关系到设计的质量，特别是系统的稳定性，所以确定类接口操作要特别小心。</li>
<li>逐个检查类在每个用例实现中是否合适，补充一些必须的操作。</li>
<li>设计时不仅要考虑到系统正常运行的情况，还要考虑一些特殊情况，如中断/错误处理等</li>
</ul>
</li>
<li>定义类之间的关系
<ul>
<li>设置基数：一个类的实例与另一个类的实例之间的联系。</li>
<li>使用关联类：可以放置与关联相关的属性。</li>
</ul>
</li>
</ol>
<h3 id="UML顺序图"><a href="#UML顺序图" class="headerlink" title="UML顺序图"></a>UML顺序图</h3>
<p>顺序图</p>
<ul>
<li>强调消息时间顺序的交互图</li>
<li>顺序图描述了对象之间传送消息的时间顺序，用来表示用例中的行为顺序</li>
<li>顺序图将交互关系表示为一个二维图，图形上看起来是一张表；
<ul>
<li>显示的对象沿横轴排列，从左到右分布在图的顶部</li>
<li>消息则沿着纵轴按时间顺序排序</li>
<li>使图尽量简洁为布局依据</li>
</ul>
</li>
</ul>
<p>示例</p>
<p><img src="/assets/Software-Engineering/image-20241027222152770.png" alt="image-20241027222152770"></p>
<p>组成</p>
<ul>
<li>
<p>对象：</p>
<ul>
<li>顺序图中对象的符号和对象图中对象所用的符号一样；</li>
<li>将对象置于顺序图的顶部意味着在交互开始的时候对象就已经存在了，如果对象的 位置不在顶部，那么表示对象是在交互的过程中被创建的；</li>
<li>活动者和对象按照从左到右的顺序排列 ，一般最多两个活动者，他们分列两端；</li>
<li>启动这个用例的活动者往往排在最左边；接 收消息的活动者则排在最右端；</li>
<li>对象从左到右按照重要性排列或按照消息先后顺序排列。</li>
<li>命名：包括对象名和类名，类名（匿名对象），对象名（不关心类）</li>
</ul>
</li>
<li>
<p>生命线</p>
<ul>
<li>每个对象都有自己的生命线，用来表 示在该用例中一个对象在一段时间内的存在</li>
<li>生命线使用垂直的虚线表示</li>
<li>如果对象生命期结束，则用注销符号表示</li>
<li>对象默认的位置在图顶部，表示对象 在交互之前已经存在</li>
<li>如果是在交互过程中由另外的对象所 创建，则位于图的中间某处。</li>
</ul>
</li>
<li>
<p>消息</p>
<ul>
<li>面向对象方法中，消息是对象间交互信息的主要方式</li>
<li>结构化程序设计中，模块间传递信息的方式主要是过程（或函数）调用</li>
<li>对象A向对象B发送消息，可以简单地理解为对象A调用对象B的一个操作</li>
<li>顺序图中，尽力保持消息的顺序是从左到右排列的</li>
<li>一个顺序图的消息流开始于左上方，消息2的位置比消息1低，这意味着消息2的顺 序比消息1要迟</li>
<li>顺序图中消息编号可显示，也可不显示。协作图中必须显示。</li>
<li>在UML中，消息使用箭头来表示，箭头的类型表示了消息的类型</li>
<li>消息的类型
<ul>
<li>简单消息</li>
<li>同步消息：同步消息最常见的情况是调用，即消息 发送者对象在它的一个操作执行时调用 接收者对象的一个操作，此时消息名称 通常就是被调用的操作名称。当消息被处理完后，可以回送一个简单 消息，或者是隐含的返回。</li>
<li>异步消息：异步消息表示发送消息的对象不用等待回应的返回消息，即可开始另一个活动。异步消息在某种程度上规定了发送方和接收方的责任，即发送方只负责将消息发送到接收 方，至于接收方如何响应，发送方则不需要知道。对接收方来说，在接收到消息后它既可 以对消息进行处理，也可以什么都不做。</li>
<li>反身消息：顺序图建模过程中，一个对象也可以将 一个消息发送给它自己，这就是反身消 息；如果一条消息只能作为反身消息，那么 说明该操作只能由对象自身的行为触发。 这表明该操作可以被设置为私有属 性，只有属于同一个类的对象才能够调用它。在这种情况下，应该对顺序图进行彻底 的检查，以确定该操作不需要被其他对 象直接调用。</li>
<li>返回消息：返回消息是顺序图的一个可选择部分， 它表示控制流从过程调用的返回。<strong>一般可以缺省</strong>，隐含表示每一个调用都有一个配对的调用返回。 是否使用返回消息依赖于建模的具体/ 抽象程度。如果需要较好的具体化，返 回消息是有用的；否则，主动消息就足 够了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>激活</p>
<ul>
<li>激活表示该对象被占用以完成某个任务，去激活指的则是对象处于空闲状态、在等 待消息。</li>
<li>在UML中，为了表示对象是激活的，可以将该对象的生命线拓宽成为矩形。其中 的矩形称为激活条(期)或控制期，对象就是在激活条的顶部被激活的，对象在完成 自己的工作后被去激活</li>
<li>特点：
<ul>
<li>当一条消息被传递给对象的时候，它会触发该对象的某个行为，这时就说该对象被激活了</li>
<li>在UML中，激活用一个在生命线上的细长矩形框表示</li>
<li>矩形本身被称为对象的激活期或控制期，对象就是在激活期顶端被激活的</li>
<li>激活期说明对象正在执行某个动作。当动作完成后，伴随着一个消息箭头离开对象的生命 线，此时对象的一个激活期也宣告结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/assets/Software-Engineering/image-20241027222301708.png" alt="image-20241027222301708"></p>
<p>对象的创建</p>
<ul>
<li>顺序图中的对象的默认位置是在图的顶部，如果对象在这个位置上，那么说明在发送消息 时，该对象就已经存在了</li>
<li>如果对象是在执行的过程中创建的，那么它的位置应该处在图的中间部分</li>
</ul>
<p><img src="/assets/Software-Engineering/image-20241027230609065.png" alt="image-20241027230609065"></p>
<p>对象的撤销</p>
<ul>
<li>在处理新创建的对象，或顺序图中的其他对象时，都可以发送“destroy”消息来撤销对象；</li>
<li>要想说明某个对象被撤销，需要在被撤 销对象的生命线末端放一个“×”符号 进行标识</li>
</ul>
<p><img src="/assets/Software-Engineering/image-20241027230621943.png" alt="image-20241027230621943"></p>
<p>建模特点</p>
<ul>
<li>对系统动态行为建模的过程中，当强调按时间展开信息的传送时，一般使用顺序图 建模技术。</li>
<li>一个单独的顺序图只能显示一个控制流。</li>
<li>一般情况下，一个完整的控制流是非常复杂的，要描述它需要创建很多交互图（包 括顺序图和协作图），一些图是主要的，另一些图用来描述可选择的路径和一些例 外，再用一个包对它们进行统一的管理。</li>
</ul>
<p>建模的参考策略</p>
<ul>
<li>设置交互的语境，这些语境可以是系统、子系统、类、用例和协作的一个脚本。</li>
<li>识别对象在交互语境中所扮演的角色，根据对象的重要性及相互关系，将其从左至右放置在顺序图的顶 部。</li>
<li>设置每个对象的生命线。通常情况下，对象存在于整个交互过程中，但它们也可以在交互过程中创建和 撤销。对于这类对象，在适当的时刻设置它们的生命线，并用适当的构造型消息显示地说明它们的创建 和撤销。</li>
<li>从引发某个消息的信息开始，在生命线之间画出从顶到底依次展开的消息，显示每个消息的内容标识。</li>
<li>设置对象的激活期，可视化消息的嵌套或可视化实际计算发生时的时间点。</li>
<li>如果需要设置时间或空间的约束，可以为每个消息附上合适的时间和空间约束。</li>
<li>如果需要形式化的说明某控制流，可以为每个消息附上前置和后置条件。</li>
</ul>
<p>建立顺序图的步骤</p>
<ul>
<li>确定交互的范围；</li>
<li>识别参与交互的对象和活动者；</li>
<li>设置对象生命线开始和结束；</li>
<li>设置消息；</li>
<li>细化消息。</li>
</ul>
<p>示例：</p>
<p><img src="/assets/Software-Engineering/image-20241027231109124.png" alt="image-20241027231109124"></p>
<h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2>
<h3 id="面向对象设计的特点"><a href="#面向对象设计的特点" class="headerlink" title="面向对象设计的特点"></a>面向对象设计的特点</h3>
<ul>
<li>面向对象设计强调定义软件对象，并且使这些软件对象相互协作来满足用户需求。</li>
<li>面向对象分析和设计的界限是模糊的，从面向对象分析到面向对象设计是一个逐渐 扩充模型的过程。分析的结果通过细化直接生成设计结果，在设计过程中逐步加深 对需求的理解，从而进一步完善需求分析的结果。</li>
<li>分析和设计活动是一个反复迭代的过程。</li>
<li>面向对象方法学在概念和表示方法上的一致性，保证了各个开发阶段之间的平滑性。</li>
</ul>
<h3 id="面向对象设计的四个层次"><a href="#面向对象设计的四个层次" class="headerlink" title="面向对象设计的四个层次"></a>面向对象设计的四个层次</h3>
<ul>
<li>确定系统的总体结构和风格，构造系统的物理模型，将系统划分成不同的子系统。</li>
<li>中层设计：对每个用例进行设计，规划实现用例功能的关键类，确定类之间的关系。</li>
<li>进行底层设计：对每个类进行详细设计，设计类的属性和操作，优化类之间的关系。</li>
<li>补充实现非功能性需求所需要的类。</li>
</ul>
<h3 id="设计高质量的软件系统"><a href="#设计高质量的软件系统" class="headerlink" title="设计高质量的软件系统"></a>设计高质量的软件系统</h3>
<ul>
<li>对接口进行设计</li>
<li>发现变化并封装它</li>
<li>先考虑聚合再考虑继承</li>
</ul>
<h4 id="强内聚"><a href="#强内聚" class="headerlink" title="强内聚"></a>强内聚</h4>
<p>类内聚：设计类的原则是一个类的属性和操作全部都是完成某个任务所必须的， 其中不包括无用的属性和操作。</p>
<h4 id="弱耦合"><a href="#弱耦合" class="headerlink" title="弱耦合"></a>弱耦合</h4>
<p>在面向对象设计中，耦合主要指不同对象之间相互关联的程度。</p>
<p>如果一个对象过多 地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。</p>
<p>对象不可能是完全孤立的，当两个对象必须相互联系时，应该通过类的公共接口实 现耦合，不应该依赖于类的具体实现细节。</p>
<p>耦合方式</p>
<ul>
<li>交互耦合：如果对象之间的耦合是通过<strong>消息连接</strong>来实现的，则这种耦合就是交互耦合。在设计时应该尽量减少对象之间发送的消息数和消息中的参数个数，降低消 息连接的复杂程度。</li>
<li>继承耦合：继承耦合是<strong>一般化类与特殊化类</strong>之间的一种关联形式，设计时应该适 当使用这种耦合。在设计时要特别认真分析一般化类与特殊化类之间继承关系，如 果抽象层次不合理，可能会造成对特殊化类的修改影响到一般化类，使得系统的稳 定性降低。另外，在设计时特殊化类应该尽可能多地继承和使用一般化类的属性和 服务，充分利用继承的优势。</li>
</ul>
<h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3>
<p>软件重用是从设计阶段开始的，所有的设计工作都是为了使系统完成预期的任务， 为了提高工作效率、减少错误、降低成本，就要充分考虑软件元素的重用性。</p>
<ul>
<li>尽量使用已有的类，包括开发环境提供的类库和已有的相似的类；</li>
<li>如果确实需要创建新类，则在设计这些新类时考虑将来的可重用性。</li>
</ul>
<p>设计一个可重用的软件比设计一个普通软件的代价要高，但是随着这些软件被重用 次数的增加，分摊到它的设计和实现成本就会降低。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3>
<p>框架是一组可用于不同应用的类的集合。</p>
<p>框架中的类通常是一些抽象类并且相互有 联系，可以通过继承的方式使用这些类。</p>
<p>一般不会直接去修改框架的类，而是通过继承或聚合为应用创建合适的GUI类。</p>
</main>


<script src="/js/theme.js"></script>


<script src="/js/code-block-header.js"></script>


<script src="/js/code-block-copy.js"></script>


<script src="/js/code-block-theme-toggle.js"></script>


<script src="/js/code-block.js"></script>



<link rel="stylesheet" href="/css/article.css">

    
    <!-- giscus评论区 -->
    
  <div id="giscus_thread"></div>

  </div>
</article>
  
</main>

      <!-- 页脚 -->
      <footer class="footer">
  
  <span>Copyright © Kytolly(shiroi)</span>
  
  <div class="theme-switch-wrapper">
    <div class="theme-switch">
      <div class="theme-switch-item light-mode active">
        <img src="/icon/light.svg" class="icon">
      </div>
      <div class="theme-switch-item dark-mode">
        <img src="/icon/dark.svg" class="icon">
      </div>
    </div>
  </div>
</footer>


<link rel="stylesheet" href="/css/footer.css">


<script src="/js/theme-switcher.js"></script>


<script src="/js/giscus.js"></script>


      
  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <img src="/icon/search.svg" alt="Search Icon" class="search-icon" style="width:1.2em;height:1.2em;vertical-align:middle;">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <img src="/icon/search.svg" alt="Search Icon" style="width:5em;height:5em;">
        </div>
        <ul id="search-results"></ul>
      </div>
    </div>
  </div>

<link rel="stylesheet" href="/css/search.css">



    </div>
    
<script src="/js/background.js"></script>

  </body>

</html>